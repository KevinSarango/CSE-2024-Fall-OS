# -*- coding: utf-8 -*-
"""cse4300project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UJiRI8k6v9bDfbHL3uqkS7T50dnLgFro
"""

import matplotlib.pyplot as plt
import pandas as pd
import random

################################################################################
############################# Task Data Generator  #############################
################################################################################
# FUNCTION: generate_tasks
# Purpose:
# Generates a list of tasks, each with a random duration, to simulate workload in
# scheduling algorithms.
#
# Inputs:
# - num_tasks: Integer representing the number of tasks to generate.
#
# Outputs:
# - A list of tuples, where each tuple contains:
#   - task_name: String representing the name of the task (e.g., "Task 1").
#   - duration: Integer representing the task duration, randomly chosen
#               between 1 and 10 units.
#
# Logic:
# 1. Initialize an empty list `tasks`.
# 2. Use a loop to generate `num_tasks`:
#    - For each iteration, create a task name (e.g., "Task 1") and a random duration.
# 3. Append each task as a tuple `(task_name, duration)` to the `tasks` list.
# 4. Return the list of generated tasks.
def generate_tasks(num_tasks):
    """Generate a list of tasks with random durations."""
    tasks = []
    for i in range(num_tasks):
        task_name = f"Task {i + 1}"
        duration = random.randint(1, 10)  # Random duration between 1 and 10 units
        tasks.append((task_name, duration))
    return tasks





################################################################################
############################### FIFO Scheduling  ###############################
################################################################################
# FUNCTION: fifo_scheduling
# Purpose:
# Implements First-In-First-Out (FIFO) scheduling, where tasks are executed
# in the order they arrive.
#
# Inputs:
# - tasks: List of tuples, where each tuple contains a task name and its duration.
#
# Outputs:
# - A list of tuples for each task, containing:
#   - Task name.
#   - Duration.
#   - Waiting time: Time a task waits before execution.
#   - Turnaround time: Time from arrival to completion.
#   - Response time: Time from arrival to first execution.
#
# Logic:
# 1. Start with `current_time = 0`.
# 2. For each task in the input list:
#    - Calculate `start_time` as `current_time`.
#    - Calculate `waiting_time` as `start_time` (since arrival is assumed at 0).
#    - Compute `turnaround_time` as `waiting_time + duration`.
#    - Set `response_time` equal to `waiting_time` (response is immediate for FIFO).
#    - Update `current_time` by adding the task duration.
# 3. Append the computed metrics to the results list.
# 4. Return the results.
def fifo_scheduling(tasks):
    """Perform FIFO scheduling and calculate metrics."""
    current_time = 0
    results = []
    for task_name, duration in tasks:
        start_time = current_time
        waiting_time = start_time
        turnaround_time = waiting_time + duration
        response_time = waiting_time
        current_time += duration
        results.append((task_name, duration, waiting_time, turnaround_time, response_time))
    return results





################################################################################
############################### SJF Scheduling  ################################
################################################################################
# FUNCTION: sjf_scheduling
# Purpose:
# Implements Shortest Job First (SJF) scheduling, which prioritizes tasks with
# shorter durations.
#
# Inputs:
# - tasks: List of tuples, where each tuple contains a task name and its duration.
#
# Outputs:
# - Same format as fifo_scheduling: A list of tuples for each task, containing
#   task name, duration, waiting time, turnaround time, and response time.
#
# Logic:
# 1. Sort the tasks by duration in ascending order.
# 2. Pass the sorted tasks to the `fifo_scheduling` function to compute metrics.
# 3. Return the results.
def sjf_scheduling(tasks):
    """Perform SJF scheduling and calculate metrics."""
    sorted_tasks = sorted(tasks, key=lambda x: x[1])  # Sort by task duration
    return fifo_scheduling(sorted_tasks)





################################################################################
########################### Round Robin Scheduling  ############################
################################################################################
# FUNCTION: round_robin_scheduling
# Purpose:
# Implements Round Robin (RR) scheduling, which allocates a fixed time slice
# (`time_quantum`) to each task in a cyclic order.
#
# Inputs:
# - tasks: List of tuples, where each tuple contains a task name and its duration.
# - time_quantum: Integer representing the maximum time allocated per task
#                 execution in a single round.
#
# Outputs:
# - Same format as fifo_scheduling: A list of tuples for each task, containing
#   task name, duration, waiting time, turnaround time, and response time.
#
# Logic:
# 1. Initialize a queue where each task is represented as
#    `(task_name, remaining_time, arrival_time)`.
# 2. Track `current_time` and initialize dictionaries for waiting times,
#    turnaround times, and response times.
# 3. While the queue is not empty:
#    - Pop the first task and compute `executed_time` as the smaller of
#      `remaining_time` and `time_quantum`.
#    - Update `current_time` with `executed_time`.
#    - If the task is unfinished, requeue it with the updated remaining time
#      and arrival time.
#    - If the task finishes, record its turnaround time and mark it as finished.
#    - Update waiting times for all other tasks in the queue during this time slice.
# 4. Compile the results into the required format and return them.
def round_robin_scheduling(tasks, time_quantum):
    """Perform Round Robin scheduling and calculate metrics."""
    queue = [(task_name, duration, 0) for task_name, duration in tasks]  # Add an 'arrival_time' (always 0 here)
    current_time = 0
    results = []
    waiting_times = {task[0]: 0 for task in tasks}
    turnaround_times = {task[0]: 0 for task in tasks}
    response_times = {}
    finished_tasks = set()

    while queue:
        task_name, remaining_time, arrival_time = queue.pop(0)

        if task_name not in response_times:  # First response time for this task
            response_times[task_name] = current_time - arrival_time

        executed_time = min(remaining_time, time_quantum)
        current_time += executed_time

        if remaining_time - executed_time > 0:  # Task not finished, requeue
            queue.append((task_name, remaining_time - executed_time, current_time))
        else:  # Task finished
            turnaround_times[task_name] = current_time
            finished_tasks.add(task_name)

        # Update waiting times for other tasks in the queue
        for queued_task in queue:
            if queued_task[0] not in finished_tasks:
                waiting_times[queued_task[0]] += executed_time

    # Compile results
    for task_name, duration in tasks:
        results.append((
            task_name,
            duration,
            waiting_times[task_name],
            turnaround_times[task_name],
            response_times[task_name]
        ))
    return results





################################################################################
########################### Visualization Function  ############################
################################################################################
# FUNCTION: visualize_scheduling
# Purpose:
# Generates bar charts to visually compare the scheduling metrics across FIFO,
# SJF, and RR algorithms.
#
# Inputs:
# - results_fifo, results_sjf, results_rr: Results of the scheduling algorithms
#   in a list format.
# - output_file: File prefix for saving the generated plots.
#
# Outputs:
# - Saves grouped bar plots for each metric as PNG files.
#
# Logic:
# 1. Convert results into pandas DataFrames for easier processing.
# 2. Define metrics (Waiting Time, Turnaround Time, Response Time) to visualize.
# 3. For each metric:
#    - Create grouped bar charts for FIFO, SJF, and RR results.
#    - Format and label the chart appropriately.
#    - Save the plot as a PNG file with the metric name in the filename.
def visualize_scheduling(results_fifo, results_sjf, results_rr, output_file):
    """Create grouped bar plots for scheduling metrics with specified colors."""
    metrics = ["Waiting Time", "Turnaround Time", "Response Time"]

    # Convert results to DataFrames
    df_fifo = pd.DataFrame(results_fifo, columns=["Task", "Duration", "Waiting Time", "Turnaround Time", "Response Time"])
    df_sjf = pd.DataFrame(results_sjf, columns=["Task", "Duration", "Waiting Time", "Turnaround Time", "Response Time"])
    df_rr = pd.DataFrame(results_rr, columns=["Task", "Duration", "Waiting Time", "Turnaround Time", "Response Time"])

    task_labels = df_fifo["Task"]
    x = range(len(task_labels))  # X-axis positions for tasks
    bar_width = 0.25  # Width of each bar

    for metric in metrics:
        plt.figure(figsize=(12, 6))

        # Create bars with offsets for grouping
        plt.bar([pos - bar_width for pos in x], df_fifo[metric], width=bar_width, label="FIFO", color='red', alpha=0.7)
        plt.bar(x, df_sjf[metric], width=bar_width, label="SJF", color='green', alpha=0.7)
        plt.bar([pos + bar_width for pos in x], df_rr[metric], width=bar_width, label="Round Robin", color='blue', alpha=0.7)

        # Formatting
        plt.xlabel("Tasks")
        plt.ylabel(metric)
        plt.title(f"Comparison of {metric} Across Scheduling Algorithms")
        plt.xticks(x, task_labels, rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.savefig(f"{output_file}_{metric.replace(' ', '_').lower()}.png")
        #plt.close()
        plt.show()




################################################################################
############################ Save Results to File  #############################
################################################################################
# FUNCTION: save_results_to_file
# Purpose:
# Writes the scheduling results into a text file for record-keeping or further analysis.
#
# Inputs:
# - results_fifo, results_sjf, results_rr: Results of the scheduling algorithms
#   in a list format.
# - output_file: Filename for saving the results.
#
# Outputs:
# - Saves a text file with a tabular representation of results for each scheduling algorithm.
#
# Logic:
# 1. Open the specified file for writing.
# 2. Write headers and results for each scheduling algorithm (FIFO, SJF, RR).
# 3. Format the output with tabs and line breaks for readability.
def save_results_to_file(results_fifo, results_sjf, results_rr, output_file):
    """Save scheduling results to a text file."""
    with open(output_file, "w") as file:
        file.write("FIFO Scheduling Results:\n")
        file.write("Task\tDuration\tWaiting Time\tTurnaround Time\tResponse Time\n")
        for row in results_fifo:
            file.write("\t".join(map(str, row)) + "\n")

        file.write("\nSJF Scheduling Results:\n")
        file.write("Task\tDuration\tWaiting Time\tTurnaround Time\tResponse Time\n")
        for row in results_sjf:
            file.write("\t".join(map(str, row)) + "\n")

        file.write("\nRound Robin Scheduling Results:\n")
        file.write("Task\tDuration\tWaiting Time\tTurnaround Time\tResponse Time\n")
        for row in results_rr:
            file.write("\t".join(map(str, row)) + "\n")





################################################################################
################################ Main Function #################################
################################################################################
# FUNCTION: main
# Purpose:
# Coordinates task generation, scheduling, visualization, and result saving.
#
# Inputs:
# - Hardcoded values for the number of tasks (`num_tasks`) and Round Robin
#   time quantum (`time_quantum`).
#
# Outputs:
# - Scheduling results saved to a text file.
# - Visualization plots saved as PNG files.
#
# Logic:
# 1. Generate tasks using `generate_tasks`.
# 2. Execute FIFO, SJF, and RR scheduling on the tasks.
# 3. Save the scheduling results to a file using `save_results_to_file`.
# 4. Visualize scheduling metrics using `visualize_scheduling`.
# 5. Print the status of saved results and visuals.
def main():
    num_tasks = 8  # Number of tasks
    time_quantum = 4  # Time quantum for Round Robin
    tasks = generate_tasks(num_tasks)

    # Perform Scheduling
    results_fifo = fifo_scheduling(tasks)
    results_sjf = sjf_scheduling(tasks)
    results_rr = round_robin_scheduling(tasks, time_quantum)

    # Output Files
    output_text_file = "scheduling_results.txt"
    output_visuals_file_prefix = "scheduling_visuals"

    # Save and Visualize
    save_results_to_file(results_fifo, results_sjf, results_rr, output_text_file)
    visualize_scheduling(results_fifo, results_sjf, results_rr, output_visuals_file_prefix)

    print(f"Results saved to {output_text_file}.")
    print(f"Visuals saved as {output_visuals_file_prefix}_<metric>.png.")








if __name__ == "__main__":
    main()